(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[133],{9190:(e,a,t)=>{let r={unstable_cache:t(7412).A,revalidateTag:t(3812).O,revalidatePath:t(3812).t,unstable_noStore:t(4647).P};e.exports=r,a.unstable_cache=r.unstable_cache,a.revalidatePath=r.revalidatePath,a.revalidateTag=r.revalidateTag,a.unstable_noStore=r.unstable_noStore},8831:(e,a,t)=>{"use strict";t.d(a,{uX:()=>s});var r,i,n=t(2780),l=t(9614);!function(e){e[e.SeeOther=303]="SeeOther",e[e.TemporaryRedirect=307]="TemporaryRedirect",e[e.PermanentRedirect=308]="PermanentRedirect"}(r||(r={}));let o="NEXT_REDIRECT";function s(e,a){void 0===a&&(a="replace");let t=l.W.getStore();throw function(e,a,t){void 0===t&&(t=r.TemporaryRedirect);let i=Error(o);i.digest=o+";"+a+";"+e+";"+t+";";let l=n.O.getStore();return l&&(i.mutableCookies=l.mutableCookies),i}(e,a,(null==t?void 0:t.isAction)?r.SeeOther:r.TemporaryRedirect)}!function(e){e.push="push",e.replace="replace"}(i||(i={}))},3812:(e,a,t)=>{"use strict";t.d(a,{t:()=>c,O:()=>d});var r=t(9092),i=t(7460);let n=/\/\[[^/]+?\](?=\/|$)/;var l=t(8997),o=t(1604),s=t(1548);function d(e){return h(e,`revalidateTag ${e}`)}function c(e,a){if(e.length>l.ux){console.warn(`Warning: revalidatePath received "${e}" which exceeded max length of ${l.ux}. See more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`);return}let t=`${l.zt}${e}`;if(a)t+=`${t.endsWith("/")?"":"/"}${a}`;else{var r;r=e,(0,i.Ag)(r)&&(r=(0,i.CK)(r).interceptedRoute),n.test(r)&&console.warn(`Warning: a dynamic page path "${e}" was passed to "revalidatePath", but the "type" parameter is missing. This has no effect by default, see more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`)}return h(t,`revalidatePath ${e}`)}function h(e,a){let t=s.A.getStore();if(!t||!t.incrementalCache)throw Error(`Invariant: static generation store missing in ${a}`);if(t.isUnstableCacheCallback)throw Error(`Route ${(0,o.RO)(t.urlPathname)} used "${a}" inside a function cached with "unstable_cache(...)" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);(0,r.TP)(t,a),t.revalidatedTags||(t.revalidatedTags=[]),t.revalidatedTags.includes(e)||t.revalidatedTags.push(e),t.pendingRevalidates||(t.pendingRevalidates={}),t.pendingRevalidates[e]=null==t.incrementalCache.revalidateTag?void 0:t.incrementalCache.revalidateTag.call(t.incrementalCache,e).catch(a=>{console.error(`revalidate failed for ${e}`,a)}),t.pathWasRevalidated=!0}},7412:(e,a,t)=>{"use strict";t.d(a,{A:()=>s});var r=t(8997),i=t(3218),n=t(1548);let l=0;async function o(e,a,t,i,n,l,o){await a.set(t,{kind:"FETCH",data:{headers:{},body:JSON.stringify(e),status:200,url:""},revalidate:"number"!=typeof n?r.BR:n},{revalidate:n,fetchCache:!0,tags:i,fetchIdx:l,fetchUrl:o})}function s(e,a,t={}){if(0===t.revalidate)throw Error(`Invariant revalidate: 0 can not be passed to unstable_cache(), must be "false" or "> 0" ${e.toString()}`);let r=t.tags?(0,i.ny)(t.tags,`unstable_cache ${e.toString()}`):[];(0,i.Z6)(t.revalidate,`unstable_cache ${e.name||e.toString()}`);let s=`${e.toString()}-${Array.isArray(a)&&a.join(",")}`;return async(...a)=>{let d=n.A.getStore(),c=(null==d?void 0:d.incrementalCache)||globalThis.__incrementalCache;if(!c)throw Error(`Invariant: incrementalCache missing in unstable_cache ${e.toString()}`);let{pathname:h,searchParams:u}=new URL((null==d?void 0:d.urlPathname)||"/","http://n"),v=[...u.keys()].sort((e,a)=>e.localeCompare(a)).map(e=>`${e}=${u.get(e)}`).join("&"),f=`${s}-${JSON.stringify(a)}`,g=await c.fetchCacheKey(f),p=`unstable_cache ${h}${v.length?"?":""}${v} ${e.name?` ${e.name}`:g}`,m=(d?d.nextFetchId:l)??1;if(d){if(d.nextFetchId=m+1,"number"==typeof t.revalidate?"number"==typeof d.revalidate&&d.revalidate<t.revalidate||(d.revalidate=t.revalidate):!1===t.revalidate&&void 0===d.revalidate&&(d.revalidate=t.revalidate),d.tags)for(let e of r)d.tags.includes(e)||d.tags.push(e);else d.tags=r.slice();let l=(0,i.RQ)(d);if("force-no-store"!==d.fetchCache&&!d.isOnDemandRevalidate&&!c.isOnDemandRevalidate&&!d.isDraftMode){let i=await c.get(g,{kindHint:"fetch",revalidate:t.revalidate,tags:r,softTags:l,fetchIdx:m,fetchUrl:p});if(i&&i.value){if("FETCH"!==i.value.kind)console.error(`Invariant invalid cacheEntry returned for ${f}`);else{let l=void 0!==i.value.data.body?JSON.parse(i.value.data.body):void 0;return i.isStale&&(d.pendingRevalidates||(d.pendingRevalidates={}),d.pendingRevalidates[f]=n.A.run({...d,fetchCache:"force-no-store",isUnstableCacheCallback:!0},e,...a).then(e=>o(e,c,g,r,t.revalidate,m,p)).catch(e=>console.error(`revalidating cache with key: ${f}`,e))),l}}}let s=await n.A.run({...d,fetchCache:"force-no-store",isUnstableCacheCallback:!0},e,...a);return o(s,c,g,r,t.revalidate,m,p),s}{if(l+=1,!c.isOnDemandRevalidate){let e=d&&(0,i.RQ)(d),a=await c.get(g,{kindHint:"fetch",revalidate:t.revalidate,tags:r,fetchIdx:m,fetchUrl:p,softTags:e});if(a&&a.value){if("FETCH"!==a.value.kind)console.error(`Invariant invalid cacheEntry returned for ${f}`);else if(!a.isStale)return void 0!==a.value.data.body?JSON.parse(a.value.data.body):void 0}}let s=await n.A.run({fetchCache:"force-no-store",isUnstableCacheCallback:!0,urlPathname:"/",isStaticGeneration:!1,prerenderState:null},e,...a);return o(s,c,g,r,t.revalidate,m,p),s}}}},4647:(e,a,t)=>{"use strict";t.d(a,{P:()=>n});var r=t(1548),i=t(9092);function n(){let e=r.A.getStore();return e?e.forceStatic?void 0:void(e.isUnstableNoStore=!0,(0,i.Zk)(e,"unstable_noStore()")):void 0}}}]);
//# sourceMappingURL=133.js.map