{"version":3,"file":"edge-chunks/133.js","mappings":"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","sources":["webpack://_N_E/./node_modules/next/cache.js","webpack://_N_E/../../../src/client/components/redirect-status-code.ts","webpack://_N_E/../../../src/client/components/redirect.ts","webpack://_N_E/../../../src/client/components/navigation.react-server.ts","webpack://_N_E/./node_modules/next/dist/esm/api/navigation.react-server.js","webpack://_N_E/../../../../../src/shared/lib/router/utils/is-dynamic.ts","webpack://_N_E/./node_modules/next/dist/esm/server/web/spec-extension/revalidate.js","webpack://_N_E/./node_modules/next/dist/esm/server/web/spec-extension/unstable-cache.js","webpack://_N_E/./node_modules/next/dist/esm/server/web/spec-extension/unstable-no-store.js"],"sourcesContent":["const cacheExports = {\n  unstable_cache: require('next/dist/server/web/spec-extension/unstable-cache')\n    .unstable_cache,\n  revalidateTag: require('next/dist/server/web/spec-extension/revalidate')\n    .revalidateTag,\n  revalidatePath: require('next/dist/server/web/spec-extension/revalidate')\n    .revalidatePath,\n  unstable_noStore:\n    require('next/dist/server/web/spec-extension/unstable-no-store')\n      .unstable_noStore,\n}\n\n// https://nodejs.org/api/esm.html#commonjs-namespaces\n// When importing CommonJS modules, the module.exports object is provided as the default export\nmodule.exports = cacheExports\n\n// make import { xxx } from 'next/cache' work\nexports.unstable_cache = cacheExports.unstable_cache\nexports.revalidatePath = cacheExports.revalidatePath\nexports.revalidateTag = cacheExports.revalidateTag\nexports.unstable_noStore = cacheExports.unstable_noStore\n",null,null,null,"export * from \"../client/components/navigation.react-server\";\n\n//# sourceMappingURL=navigation.react-server.js.map",null,"import { trackDynamicDataAccessed } from \"../../app-render/dynamic-rendering\";\nimport { isDynamicRoute } from \"../../../shared/lib/router/utils\";\nimport { NEXT_CACHE_IMPLICIT_TAG_ID, NEXT_CACHE_SOFT_TAG_MAX_LENGTH } from \"../../../lib/constants\";\nimport { getPathname } from \"../../../lib/url\";\nimport { staticGenerationAsyncStorage } from \"../../../client/components/static-generation-async-storage.external\";\n/**\n * This function allows you to purge [cached data](https://nextjs.org/docs/app/building-your-application/caching) on-demand for a specific cache tag.\n *\n * Read more: [Next.js Docs: `revalidateTag`](https://nextjs.org/docs/app/api-reference/functions/revalidateTag)\n */ export function revalidateTag(tag) {\n    return revalidate(tag, `revalidateTag ${tag}`);\n}\n/**\n * This function allows you to purge [cached data](https://nextjs.org/docs/app/building-your-application/caching) on-demand for a specific path.\n *\n * Read more: [Next.js Docs: `revalidatePath`](https://nextjs.org/docs/app/api-reference/functions/revalidatePath)\n */ export function revalidatePath(originalPath, type) {\n    if (originalPath.length > NEXT_CACHE_SOFT_TAG_MAX_LENGTH) {\n        console.warn(`Warning: revalidatePath received \"${originalPath}\" which exceeded max length of ${NEXT_CACHE_SOFT_TAG_MAX_LENGTH}. See more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`);\n        return;\n    }\n    let normalizedPath = `${NEXT_CACHE_IMPLICIT_TAG_ID}${originalPath}`;\n    if (type) {\n        normalizedPath += `${normalizedPath.endsWith(\"/\") ? \"\" : \"/\"}${type}`;\n    } else if (isDynamicRoute(originalPath)) {\n        console.warn(`Warning: a dynamic page path \"${originalPath}\" was passed to \"revalidatePath\", but the \"type\" parameter is missing. This has no effect by default, see more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`);\n    }\n    return revalidate(normalizedPath, `revalidatePath ${originalPath}`);\n}\nfunction revalidate(tag, expression) {\n    const store = staticGenerationAsyncStorage.getStore();\n    if (!store || !store.incrementalCache) {\n        throw new Error(`Invariant: static generation store missing in ${expression}`);\n    }\n    if (store.isUnstableCacheCallback) {\n        throw new Error(`Route ${getPathname(store.urlPathname)} used \"${expression}\" inside a function cached with \"unstable_cache(...)\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);\n    }\n    // a route that makes use of revalidation APIs should be considered dynamic\n    // as otherwise it would be impossible to revalidate\n    trackDynamicDataAccessed(store, expression);\n    if (!store.revalidatedTags) {\n        store.revalidatedTags = [];\n    }\n    if (!store.revalidatedTags.includes(tag)) {\n        store.revalidatedTags.push(tag);\n    }\n    if (!store.pendingRevalidates) {\n        store.pendingRevalidates = {};\n    }\n    store.pendingRevalidates[tag] = store.incrementalCache.revalidateTag == null ? void 0 : store.incrementalCache.revalidateTag.call(store.incrementalCache, tag).catch((err)=>{\n        console.error(`revalidate failed for ${tag}`, err);\n    });\n    // TODO: only revalidate if the path matches\n    store.pathWasRevalidated = true;\n}\n\n//# sourceMappingURL=revalidate.js.map","import { CACHE_ONE_YEAR } from \"../../../lib/constants\";\nimport { addImplicitTags, validateRevalidate, validateTags } from \"../../lib/patch-fetch\";\nimport { staticGenerationAsyncStorage } from \"../../../client/components/static-generation-async-storage.external\";\nlet noStoreFetchIdx = 0;\nasync function cacheNewResult(result, incrementalCache, cacheKey, tags, revalidate, fetchIdx, fetchUrl) {\n    await incrementalCache.set(cacheKey, {\n        kind: \"FETCH\",\n        data: {\n            headers: {},\n            // TODO: handle non-JSON values?\n            body: JSON.stringify(result),\n            status: 200,\n            url: \"\"\n        },\n        revalidate: typeof revalidate !== \"number\" ? CACHE_ONE_YEAR : revalidate\n    }, {\n        revalidate,\n        fetchCache: true,\n        tags,\n        fetchIdx,\n        fetchUrl\n    });\n    return;\n}\n/**\n * This function allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.\n *\n * Read more: [Next.js Docs: `unstable_cache`](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)\n */ export function unstable_cache(cb, keyParts, options = {}) {\n    if (options.revalidate === 0) {\n        throw new Error(`Invariant revalidate: 0 can not be passed to unstable_cache(), must be \"false\" or \"> 0\" ${cb.toString()}`);\n    }\n    // Validate the tags provided are valid\n    const tags = options.tags ? validateTags(options.tags, `unstable_cache ${cb.toString()}`) : [];\n    // Validate the revalidate options\n    validateRevalidate(options.revalidate, `unstable_cache ${cb.name || cb.toString()}`);\n    // Stash the fixed part of the key at construction time. The invocation key will combine\n    // the fixed key with the arguments when actually called\n    // @TODO if cb.toString() is long we should hash it\n    // @TODO come up with a collision-free way to combine keyParts\n    // @TODO consider validating the keyParts are all strings. TS can't provide runtime guarantees\n    // and the error produced by accidentally using something that cannot be safely coerced is likely\n    // hard to debug\n    const fixedKey = `${cb.toString()}-${Array.isArray(keyParts) && keyParts.join(\",\")}`;\n    const cachedCb = async (...args)=>{\n        const store = staticGenerationAsyncStorage.getStore();\n        // We must be able to find the incremental cache otherwise we throw\n        const maybeIncrementalCache = (store == null ? void 0 : store.incrementalCache) || globalThis.__incrementalCache;\n        if (!maybeIncrementalCache) {\n            throw new Error(`Invariant: incrementalCache missing in unstable_cache ${cb.toString()}`);\n        }\n        const incrementalCache = maybeIncrementalCache;\n        const { pathname, searchParams } = new URL((store == null ? void 0 : store.urlPathname) || \"/\", \"http://n\");\n        const sortedSearchKeys = [\n            ...searchParams.keys()\n        ].sort((a, b)=>{\n            return a.localeCompare(b);\n        });\n        const sortedSearch = sortedSearchKeys.map((key)=>`${key}=${searchParams.get(key)}`).join(\"&\");\n        // Construct the complete cache key for this function invocation\n        // @TODO stringify is likely not safe here. We will coerce undefined to null which will make\n        // the keyspace smaller than the execution space\n        const invocationKey = `${fixedKey}-${JSON.stringify(args)}`;\n        const cacheKey = await incrementalCache.fetchCacheKey(invocationKey);\n        // $urlWithPath,$sortedQueryStringKeys,$hashOfEveryThingElse\n        const fetchUrl = `unstable_cache ${pathname}${sortedSearch.length ? \"?\" : \"\"}${sortedSearch} ${cb.name ? ` ${cb.name}` : cacheKey}`;\n        const fetchIdx = (store ? store.nextFetchId : noStoreFetchIdx) ?? 1;\n        if (store) {\n            store.nextFetchId = fetchIdx + 1;\n            // We are in an App Router context. We try to return the cached entry if it exists and is valid\n            // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n            // the background. If the entry is missing or invalid we generate a new entry and return it.\n            // We update the store's revalidate property if the option.revalidate is a higher precedence\n            if (typeof options.revalidate === \"number\") {\n                if (typeof store.revalidate === \"number\" && store.revalidate < options.revalidate) {\n                // The store is already revalidating on a shorter time interval, leave it alone\n                } else {\n                    store.revalidate = options.revalidate;\n                }\n            } else if (options.revalidate === false && typeof store.revalidate === \"undefined\") {\n                // The store has not defined revalidate type so we can use the false option\n                store.revalidate = options.revalidate;\n            }\n            // We need to accumulate the tags for this invocation within the store\n            if (!store.tags) {\n                store.tags = tags.slice();\n            } else {\n                for (const tag of tags){\n                    // @TODO refactor tags to be a set to avoid this O(n) lookup\n                    if (!store.tags.includes(tag)) {\n                        store.tags.push(tag);\n                    }\n                }\n            }\n            // @TODO check on this API. addImplicitTags mutates the store and returns the implicit tags. The naming\n            // of this function is potentially a little confusing\n            const implicitTags = addImplicitTags(store);\n            if (// when we are nested inside of other unstable_cache's\n            // we should bypass cache similar to fetches\n            store.fetchCache !== \"force-no-store\" && !store.isOnDemandRevalidate && !incrementalCache.isOnDemandRevalidate && !store.isDraftMode) {\n                // We attempt to get the current cache entry from the incremental cache.\n                const cacheEntry = await incrementalCache.get(cacheKey, {\n                    kindHint: \"fetch\",\n                    revalidate: options.revalidate,\n                    tags,\n                    softTags: implicitTags,\n                    fetchIdx,\n                    fetchUrl\n                });\n                if (cacheEntry && cacheEntry.value) {\n                    // The entry exists and has a value\n                    if (cacheEntry.value.kind !== \"FETCH\") {\n                        // The entry is invalid and we need a special warning\n                        // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n                        // so bugs can be reported\n                        // @TODO the invocation key can have sensitive data in it. we should not log this entire object\n                        console.error(`Invariant invalid cacheEntry returned for ${invocationKey}`);\n                    // will fall through to generating a new cache entry below\n                    } else {\n                        // We have a valid cache entry so we will be returning it. We also check to see if we need\n                        // to background revalidate it by checking if it is stale.\n                        const cachedResponse = cacheEntry.value.data.body !== undefined ? JSON.parse(cacheEntry.value.data.body) : undefined;\n                        if (cacheEntry.isStale) {\n                            // In App Router we return the stale result and revalidate in the background\n                            if (!store.pendingRevalidates) {\n                                store.pendingRevalidates = {};\n                            }\n                            // We run the cache function asynchronously and save the result when it completes\n                            store.pendingRevalidates[invocationKey] = staticGenerationAsyncStorage.run({\n                                ...store,\n                                // force any nested fetches to bypass cache so they revalidate\n                                // when the unstable_cache call is revalidated\n                                fetchCache: \"force-no-store\",\n                                isUnstableCacheCallback: true\n                            }, cb, ...args).then((result)=>{\n                                return cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);\n                            })// @TODO This error handling seems wrong. We swallow the error?\n                            .catch((err)=>console.error(`revalidating cache with key: ${invocationKey}`, err));\n                        }\n                        // We had a valid cache entry so we return it here\n                        return cachedResponse;\n                    }\n                }\n            }\n            // If we got this far then we had an invalid cache entry and need to generate a new one\n            const result = await staticGenerationAsyncStorage.run({\n                ...store,\n                // force any nested fetches to bypass cache so they revalidate\n                // when the unstable_cache call is revalidated\n                fetchCache: \"force-no-store\",\n                isUnstableCacheCallback: true\n            }, cb, ...args);\n            cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);\n            return result;\n        } else {\n            noStoreFetchIdx += 1;\n            // We are in Pages Router or were called outside of a render. We don't have a store\n            // so we just call the callback directly when it needs to run.\n            // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n            // the background. If the entry is missing or invalid we generate a new entry and return it.\n            if (!incrementalCache.isOnDemandRevalidate) {\n                // We aren't doing an on demand revalidation so we check use the cache if valid\n                // @TODO check on this API. addImplicitTags mutates the store and returns the implicit tags. The naming\n                // of this function is potentially a little confusing\n                const implicitTags = store && addImplicitTags(store);\n                const cacheEntry = await incrementalCache.get(cacheKey, {\n                    kindHint: \"fetch\",\n                    revalidate: options.revalidate,\n                    tags,\n                    fetchIdx,\n                    fetchUrl,\n                    softTags: implicitTags\n                });\n                if (cacheEntry && cacheEntry.value) {\n                    // The entry exists and has a value\n                    if (cacheEntry.value.kind !== \"FETCH\") {\n                        // The entry is invalid and we need a special warning\n                        // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n                        // so bugs can be reported\n                        console.error(`Invariant invalid cacheEntry returned for ${invocationKey}`);\n                    // will fall through to generating a new cache entry below\n                    } else if (!cacheEntry.isStale) {\n                        // We have a valid cache entry and it is fresh so we return it\n                        return cacheEntry.value.data.body !== undefined ? JSON.parse(cacheEntry.value.data.body) : undefined;\n                    }\n                }\n            }\n            // If we got this far then we had an invalid cache entry and need to generate a new one\n            // @TODO this storage wrapper is included here because it existed prior to the latest refactor\n            // however it is incorrect logic because it causes any internal cache calls to follow the App Router\n            // path rather than Pages router path. This may mean there is existing buggy behavior however no specific\n            // issues are known at this time. The whole static generation storage pathways should be reworked\n            // to allow tracking which \"mode\" we are in without the presence of a store or not. For now I have\n            // maintained the existing behavior to limit the impact of the current refactor\n            const result = await staticGenerationAsyncStorage.run(// We are making a fake store that is useful for scoping fetchCache: 'force-no-store' and isUnstableCacheCallback: true\n            // The fact that we need to construct this kind of fake store indicates the code is not factored correctly\n            // @TODO refactor to not require this fake store object\n            {\n                // force any nested fetches to bypass cache so they revalidate\n                // when the unstable_cache call is revalidated\n                fetchCache: \"force-no-store\",\n                isUnstableCacheCallback: true,\n                urlPathname: \"/\",\n                isStaticGeneration: false,\n                prerenderState: null\n            }, cb, ...args);\n            cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);\n            return result;\n        }\n    };\n    // TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary\n    return cachedCb;\n}\n\n//# sourceMappingURL=unstable-cache.js.map","import { staticGenerationAsyncStorage } from \"../../../client/components/static-generation-async-storage.external\";\nimport { markCurrentScopeAsDynamic } from \"../../app-render/dynamic-rendering\";\n/**\n * This function can be used to declaratively opt out of static rendering and indicate a particular component should not be cached.\n *\n * It marks the current scope as dynamic.\n *\n * - In [non-PPR](https://nextjs.org/docs/app/api-reference/next-config-js/partial-prerendering) cases this will make a static render\n * halt and mark the page as dynamic.\n * - In PPR cases this will postpone the render at this location.\n *\n * If we are inside a cache scope then this function does nothing.\n *\n * @note It expects to be called within App Router and will error otherwise.\n *\n * Read more: [Next.js Docs: `unstable_noStore`](https://nextjs.org/docs/app/api-reference/functions/unstable_noStore)\n */ export function unstable_noStore() {\n    const callingExpression = \"unstable_noStore()\";\n    const store = staticGenerationAsyncStorage.getStore();\n    if (!store) {\n        // This generally implies we are being called in Pages router. We should probably not support\n        // unstable_noStore in contexts outside of `react-server` condition but since we historically\n        // have not errored here previously, we maintain that behavior for now.\n        return;\n    } else if (store.forceStatic) {\n        return;\n    } else {\n        store.isUnstableNoStore = true;\n        markCurrentScopeAsDynamic(store, callingExpression);\n    }\n}\n\n//# sourceMappingURL=unstable-no-store.js.map"],"names":["cacheExports","unstable_cache","__webpack_require__","A","revalidateTag","O","revalidatePath","t","unstable_noStore","P","module","exports","RedirectStatusCode","REDIRECT_ERROR_CODE","redirect","url","type","actionStore","actionAsyncStorage","getStore","getRedirectError","statusCode","TemporaryRedirect","error","digest","requestStore","requestAsyncStorage","mutableCookies","isAction","SeeOther","RedirectType","TEST_ROUTE","tag","revalidate","originalPath","length","constants","ux","console","warn","normalizedPath","zt","endsWith","route","isInterceptionRouteAppPath","extractInterceptionRouteInformation","interceptedRoute","test","expression","store","static_generation_async_storage_external","incrementalCache","isUnstableCacheCallback","RO","urlPathname","dynamic_rendering","TP","revalidatedTags","includes","push","pendingRevalidates","call","catch","err","pathWasRevalidated","noStoreFetchIdx","cacheNewResult","result","cacheKey","tags","fetchIdx","fetchUrl","set","kind","data","headers","body","JSON","stringify","status","_lib_constants__WEBPACK_IMPORTED_MODULE_0__","BR","fetchCache","cb","keyParts","options","toString","_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_1__","ny","Z6","name","fixedKey","Array","isArray","join","args","_client_components_static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_2__","maybeIncrementalCache","globalThis","__incrementalCache","pathname","searchParams","URL","sortedSearch","sortedSearchKeys","keys","sort","a","b","localeCompare","map","key","get","invocationKey","fetchCacheKey","nextFetchId","slice","implicitTags","RQ","isOnDemandRevalidate","isDraftMode","cacheEntry","kindHint","softTags","value","cachedResponse","undefined","parse","isStale","run","then","isStaticGeneration","prerenderState","_client_components_static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_0__","forceStatic","isUnstableNoStore","_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_1__","Zk"],"sourceRoot":""}